---
title: Rust 异步编程（三）：Pin 详解
date: 2023-02-23 00:58:13
published: false
tags:
categories:
- Rust
---

本节不讲异步编程。但 Pin 最先出现的地方就是在我们使用 Future 的时候，因此放入 异步编程里面讲了。

Pin 的确是一个很特殊的容器，官方文档和其它查到的资料实在晦涩难懂，甚至我一度怀疑写那些文档的人自己看懂没有。还是那一句话，如果文档和各种资料都看不懂的话，那么，看源码就可以了。

但实际上，Pin 却又是非常简单的容器，甚至可以这么说，它的特殊之处就是因为它比较简单。Pin 如此之简单，以至于我一句话就可以把 Pin 的作用说完：Pin 是一个禁止返回 &mut T 而设计出来的容器。

是的，我再重复一遍：Pin 是一个禁止返回 &mut T 而设计出来的容器。这就是 Pin 的作用。是不是很简单，不需要去讲内存移动，数据移动这些例子，如果你看了那些例子，反倒更不知道 Pin 到底在做什么了。

稍微展开点说，如果有什么容器，你想去掉它的 mut 方法，那么就把它放到 Pin 里面，这样再也无法通过成员方法获得 &mut T 了，于是，官方文档的例子中的 std::mem::swap 自然编译不通过，也就踩不到内存移动的坑了。这就是设计出 Pin 的目的：为了不让使用者去移动 struct 里面的东西，包装了一层使得外部无法获得 &mut T。

怎么样，是不是简单得很，如果你理解以上的内容但没有兴趣了解源码，仅仅只是想知道 Pin 用来做什么的话，就不需要往下看了。总之，以后如果你想禁用某个容器的 mut 方法，那就放到 Pin 里面就对了。不需要去纠结官方文档中说的那些内存，指针等例子，真相没有那么玄学，不要被官方文档的例子吓到。

下面，我除了讲 Pin 源码，我还会讲一些 Rust 原始指针的内容，加深对 Rust 的底层理解，加深对 Pin 的设计原理的理解。把这些都讲完后，我们回过头去看官方文档的例子，会瞬间觉得非常简单且好理解。
