---
title: 挖矿与脚本校验
date: 2023-02-25 16:18:12
tags:
categories:
- Blockchain
---

今天再讲讲挖矿和交易校验的一些细节。

<!--more-->

## 矿池

区块链诞生之初，一般的电脑都可以参与挖矿，但现在一般人已经很难参与挖矿了，因为比特币价值很高了（虽然最近一直熊市），参与挖矿的竞争对手越来越多，算力越来越强，大部分区块都是由非常有实力的矿池挖出的，比如写这篇文章时，最近 24 小时的出块前六情况如下（数据来自：https://www.blockchain.com/explorer/charts/pools ）：

| **Miner / Pool** | **Percent** | **Blocks Mined** |
| ---------------- | ----------- | ---------------- |
| Foundry USA      | 32.679%     | 516              |
| AntPool          | 18.049%     | 285              |
| F2Pool           | 15.453%     | 244              |
| Binance Pool     | 10.260%     | 162              |
| ViaBTC           | 8.043%      | 127              |
| Unknown          | 2.723%      | 43               |

可以看到，Foundry USA 这个区块节点已经有 32.679% 的算力了。当算力接近 51% 的时候就相当于有了很大的区块控制权，这样和去中心化的初衷违背，一般会调整难度，使得难度下降，让其它节点更有可能抢到出块权（前面说过，挖矿的概率是独立的，即使算力很强，挖到矿的概率大家都是均等的，这样，降低难度可以让其它节点更有机会挖到矿）。

另外，即使挖到矿，也有可能不会获得出块奖励，因为如前面所说，区块链有可能出现分叉，这样自己挖到的那个区块可能不是出于最长链中，导致被回滚，这样也降低了区块链被中心化的概率。



### 挖矿设备

第一代挖矿设备就是我们的一般计算机，其主要是靠 CPU 挖矿，在竞争不激烈的时代这么做是没问题的。但随着比特币价值的上升，竞争激烈后，大家升级了挖矿硬件，由 CPU 升级为 GPU，即提高了并行计算的能力。但即使如此， GPU 毕竟是显卡设备，第三代设备则升级为专业的挖矿芯片设备 ASIC： application specific integrated circus。并且，大家也不再单独挖矿，而是以矿池的运作方式进行挖矿。



### 矿主和矿工

所谓矿池，即分为矿主和矿工，矿主主要维护一个全节点，而矿工作为轻节点则只做区块头部的哈希运算，当矿工挖到区块后，就告诉矿主，由矿主提交给区块链。矿池在获得出块奖励后，会给各个矿工一部分奖励。



#### 激励矿工和防止划水

那么，这么做会不会有划水矿工呢？矿主为了激励矿工尽可能的挖到区块，除了挖到目标区块以外，还会稍微降低区块的难度，即增大 target 值，并告诉矿工，只要能挖到越过这个降低难度的 target 值，即使最后没有挖到区块而是由其它矿工挖到的，那么也会享受到一部分奖励，这样，矿工就会尽可能的去挖新的区块，如果划水，那么因为没有越过矿主规定的 target 值，也就分不到奖励了。一般来说，矿工提交的次数越多，奖励也就越多。



#### 防止矿工独自提交区块获得奖励

矿工挖到矿后，有没有可能自己提交到区块链并获得出块奖励呢？自己提交到区块链是有可能的，但获得出块奖励却不行。因为矿主给到矿工的区块头是包含了 merkle tree 的根哈希值的，这个 merkle tree 中，包含了铸币交易，而铸币交易中，填写的收款人地址（即矿主的公钥哈希值）是矿主，因此矿工如果越过矿主提交到区块链，那么，出块奖励还是会给到矿主而不是矿工。



#### 矿工攻击

矿主之间会存在竞争，一种恶性竞争就是，一个矿主给另一个矿主派去大量无用的矿工，这些矿工只是拉那个矿主的后腿，即使挖到了矿也不会提交给矿主，导致矿主分配出去的任务无效。



## 交易校验

这一小节我们讲一下区块链的交易校验细节。我们知道，区块链交易分为两种，一种是出块奖励，此时称为铸币交易，这种交易的比特币是凭空产生的，当然金额是周期性递减直到为0。一种是转账交易，即多对多的转账，此时我们需要交易金额，即最基本的：
$$
上一笔交易的输出金额 = 本次交易的输入金额
$$
简单来说即“输出 = 输入”。校验是依赖于脚本实现的，上一笔交易中，会指定输出脚本，而本次交易中，会指定输入脚本，分别依次执行输入脚本和输出脚本，脚本不报错则认为交易校验通过。

一笔简单的交易画成图如下：

![交易的校验](https://www.jackhuang.cc/svg/blockchain-verify-dealing.svg)

如上图，A 给 B 转账后，会输出 A 和 B 的余额，已经手续费等信息，同时还会有输出脚本，同样，B 转给 C时，会产生 B 的输入金额和撕咬签名，以及用于校验的输入脚本，区块链系统会依次执行输入脚本和输出脚本，只要不返回异常，那么交易就算通过了。

交易校验主要分为三种：

### P2PK (Pay to Public Key)

这是最简单的一种，虽然现在已经很少用，但实际上确可以易于我们理解，其过程为：

```rust
input script:
	PUSHDATA(Sig)
output script:
	PUSHDATA(PubKey)
	CHECKSIG
```

其只有三个步骤，第一个步骤即输入脚本的 PUSHDATA(Sig)，即把出钱方的私钥签名压入栈中，然后执行上一个交易的输入脚本第一条语句：PUSHDATA(PubKey)，即把上一个交易的输出方的公钥压入栈中，最后执行 CHECKSIG，即校验栈中的两个私钥签名和公钥是否匹配，若匹配则校验通过。

可以看出，区块链的这个脚本执行和汇编代码原理很像，即把数据压入栈中，相当于后面调用的函数的参数，然后调用参数同时出栈与之关联的参数。



### P2PKH (Pay to Public Key Hash)

前面一种仅校验了出款方的私钥，设想，如果有一个恶意用户重放这笔交易，但公私钥签名是恶意用户的，但出款方地址是受害者的，那么 P2PK 方式是无法校验出来的。因此，输入脚本除了需要校验出款方的公私钥签名以外，还需要校验出款方的地址是否和输出脚本中的一致：

```rust
input script:
	PUSHDATA(Sig)
	PUSHDATA(PubKey)
output script:
	DUP 
	HASH160 
	PUSHDATA(PubKeyHash) 
	EQUALVERIFY 
	CHECKSIG
```

上面的代码中，首先执行输入脚本的 PUSHDATA(Sig) 将出款方的私钥签名压入栈中，然后 PUSHDATA(PubKey) 压入出款方的公钥。接着执行输出脚本的 DUP，DUP函数会把栈顶数据复制一份，即此时，栈如下：

![](https://www.jackhuang.cc/svg/blockchain-key1.svg)

接着执行 HASH160，即把顶端的公钥进行哈希，而后 PUSHDATA(PubKeyHash) 压入出款方的公钥哈希，这里特别提示，公钥哈希即出款方的地址：

![](https://www.jackhuang.cc/svg/blockchain-key2.svg)

EQUALVERIFY 指令则是将 栈顶的两个哈希值对比是否相等，即地址校验，成功后栈如下：

![](https://www.jackhuang.cc/svg/blockchain-key3.svg)

因此，CHECKSIG 即校验公私钥签名完成校验。



### P2SH (Pay to Script Hash) 和 P2PKH 结合

P2SH 是在 P2PKH 的基础上增加了 redeem 脚本，即赎回脚本，稍微解释即：出款方在输出的时候会指定校验细节，这个细节写入redeem 脚本供下一次交易校验。简单来说，即想用使用出款方的钱，就必须满足上一次交易时出款方定下的规则，否则不予交易。例如这么一个场景，A 获得比特币时，在输出脚本的 redeem 脚本中指定要想使用 A 的余额，B 也要出钱，如此 redeem 脚本会校验 B 的私钥签名和地址。

下面拿一个例子讲：

```rust
redeemScript：
	PUSHDATA(Sig_A)
  PUSHDATA(Sig_B)
  2
	PUSHDATA(PubKey_B)
  PUSHDATA(PubKey_A)
  2
	CHECKSIG
input script:
	PUSHDATA(serialized redeemScript)
output script:
	HASH160 
	PUSHDATA(redeemScriptHash) 
	EQUAL
```

首先，从输入脚本开始，PUSHDATA(serialized redeemScript) 分别压入出款方的私钥签名和 redeem 脚本，然后 HASH160 将序列化后的 redeem 脚本做一次哈希，然后输出脚本的 PUSHDATA(redeemScriptHash) 指令也把自己的 redeem 脚本哈希压入栈：

![](https://www.jackhuang.cc/svg/blockchain-key4.svg)

此时执行 EQUAL 就可以对比两个 redeem 是否一致，保证本次交易 redeem 的代码时执行出款方的意愿。完成后，进入 redeemScript片段，片段中即将 A 和 B 的私钥及公钥压入栈中，然后进行验签，其原理大致同前不再赘述，通过后交易校验即通过。



### Proof of Burn

有一种特殊的输出脚本，它不管怎么样都会执行 RETURN 语句，这个语句会返回错误，也就是说，如果进行交易校验，那么一定会失败，也即校验不通过。相当于上一个交易的输出金额将无法使用。那么这种脚本有什么用呢？因为 RETURN 语句一定返回失败，因此，RETURN 语句后面的内容无论如何都无法执行，因此可以写入任何东西，例如，某人预测足球比赛的结果，他会把足球比赛的结果取哈希后写入输出脚本中，这个交易就相当于一个用来记一个不可篡改的信息的交易。当然，这样做的话，会给 UTXO 系统造成负担，毕竟， UTXO 是全节点所有的输出记录集合，如果大量写入这种无法使用的输出记录，那么 UTXO 会变得难以维护。



