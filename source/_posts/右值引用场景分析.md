---
title: C++右值引用场景分析
date: 2023-01-05 12:42:57
published: false
tags:
categories:
- C++
---

今天就向右值引用的使用场景进行开炮。

首先，几句话快速复习左值右值：

左值：有一个生命范围的值。左值有名称。

右值：不像左值在某个范围都能存在，而右值生命始于某一行也终于那一行的值，除非有右值引用接住它的资源，否则过了那一行就要变成invalid的值。std::move可以把左值转为右值，进而执行资源转移语义。右值无名称，但右值的引用可以有名称。

我们先写一个基本类，好跟踪调试：

```c++
class MyString{
    char* s_{nullptr};
public:
    MyString(const char* other) {
        std::cout << "in common constructor!" << std::endl;
        copy(other);
    }
    ~MyString() {
        release();
    }
    MyString(const MyString& other) {
        std::cout << "in left value reference!" << std::endl;
        copy(other.s_);
    }
    MyString(MyString&& other) {
        std::cout << "in right value reference!" << std::endl;
        copy(other.s_);
        other.release();
    }
    
    const char* what() const {
        return s_;
    }
    
    void destroy() {
        release();
    }
 
private:
    void release() {
        delete[] s_;
        s_ = nullptr;
    }
    void copy(const char* other) {
        release();
        int len = (int)strlen(other);
        s_ = new char[len + 1];
        strncpy(s_, other, len);
        s_[len] = 0;
    }
};

template <class T>
class Whatis;

std::ostream& operator<<(std::ostream& out, const MyString& s) {
    out << s.what();
    return out;
}
```



## 右值引用作为函数参数

### 具体类

假设我们现在要打印一个MyString对象，如果函数使用的是一个具体的右值引用（即MyString&&）参数，那么，它就是右值引用，即只接受右值：

 ```c++
 void print_my_string(MyString&& s) {
     using boost::typeindex::type_id_with_cvr;
     
     std::cout << type_id_with_cvr<decltype(s)>().pretty_name() << std::endl;
     std::cout << "s = " << s << std::endl;
 }
 ```

若打算传一个左值，那就会报错：

```c++
    MyString s("hello world!");
    
    print_my_string(s);
```

此时会报：

```c++
No matching function for call to 'print_my_string'
```

因为print_my_string需要的就是一个右值，必须给它一个右值，比如一个函数返回的临时变量：

```c++
MyString make_my_string(const char* something) {
    return MyString(something);
}

int main() {
    print_my_string(make_my_string("hello world!"));

    return 0;
}
```

因为make_my_string返回了一个局部变量，且make_my_string返回的是一个对象，因此这里相当于返回一个临时变量MyString，因为是临时的，没人接手它的资源就要被销毁了，所以是名副其实的右值，此时满足print_my_string的入参条件，编译没问题，运行结果如下：

```c++
in common constructor!
MyString&&
s = hello world!
```

可以看到，并没有调用太多的构造函数，尤其是没有去调用右值引用的拷贝构造函数，这当然是优化的结果（return value optimization）。尽管如此，依赖右值引用入参的print_my_string还是被调用了，符合预期。

总之，当函数的入参是一个具体的右值引用参数时，那么它就是一个右值引用参数，不能是其它值。可是，一旦把具体的右值引用参数改成模板类型，就发生巨大的改变。

### 模板

## 右值引用作为函数返回值

### 具体类

### 模板

## auto&&



