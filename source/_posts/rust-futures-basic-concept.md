---
title: Rust 异步编程（一）：基本概念和编程模型
date: 2023-02-10 23:41:58
published: false
tags:
categories:
- Rust
---

Rust 的异步编程内容太庞大了，从最基础的 futures，到各种第三方库，都有很多内容可讲，今天开始，Rust 编程会聚集到异步编程上，当然，异步编程不仅仅是异步，实际也会涵盖比如网络编程等方面。现在，先来个最基础的开胃菜，基本概念和简单的异步编程。

<!--more-->

## 线程的上下文切换

现在的服务器操作系统都是多任务可打断式的，即多个任务同时在跑，任务之间会争夺CPU和内存资源。操作系统会有一套算法来调度这些任务，Linux 系统中最经典的就是公平调度算法，算法的思想很简单，就是每次总是运行获得CPU时间最小的那个任务。

那么什么时候触发这个调度算法呢？有两个时间点：

1、周期性的调度；即操作系统总是周期性的做一些事情，这个是不可打断的，比如周期性的更新系统时间，周期性的看看IO是否OK，当然也就包括周期性的执行任务的调度算法；

2、系统调用的时候；即用户态在调用系统调用的时候，会陷入内核态，内核态除了完成用户态的请求，还会执行一次任务调度。

周期性的执行是不可打断的事情，属于实时调度，这方面我们的进程作为用户态的程序，一般没有机会去优化。

但系统调用却是靠我们用户态的程序来触发的。所谓系统调用，就是调用操作系统的原生接口，比如sleep，poll等，也就是说，如果我们的程序调用系统调用，会触发一些列的操作系统操作：

1、切换上下文到内核态；

2、完成用户态请求；

3、进行任务调度；

4、切换上下文回到用户态。

可能还有其它更多的事情，因此，系统调用代价是很大的。如果有两个线程，那么这两个线程的争夺将触发一系列的代价。



## IO密集型和CPU密集型任务

我们从系统资源的角度去看线程任务的话，那么主要分为两种：IO 密集型任何和CPU 密集型任务。前者主要会有大量的 IO 操作，因为需要 IO，因此会产生大量的系统调用，比如 read，write，accept 等等，按前面所说，这里将有巨大的上下文切换代价；后者则主要占用 CPU 资源，几乎没有系统调用，但会有大量的应用代码，比如 for， while ，loop，以及对 cache 对内存的频繁访问。

因此，分离 IO 密集型的任务和 CPU 密集型任务到不同的线程，就有助于提高线程的执行效率，比如一个请求，需要算一算，再读一下DB，最后再算一算，再返回给客户端，一共四个步骤，如果我们按照 IO 密集型和 CPU 密集型任务分离，那么就是两类操作，即读 DB 和返回客户端是 IO密集型任务，算一算则是 CPU 密集型任务，我们的思路是：遇到 IO 任务，则挂起，去做别的事情，保证我们的工作线程跑满 CPU，这样分离后，CPU 利用率就能极大提高，而且，因为遇到 IO 任务，我们去做别的事情不是线程切换，而是应用层的一种调度，这样减少了上下文的切换，减少了系统调度的代价。



## Rust 的异步trait库——futures

futures 库提供了最基本的上面说的任务模型最基本的trait，官方文档中给了一个比较复杂的例子（其实不复杂，但对于最初的学习者来说，可能会遇到大量的信息应付不过来，工程上，已经有很成熟的 tokio 库实现，这个库以后再讲，我们先把底层原理学清楚），我这里打算从一个更简单的例子开始慢慢演化成 Rust 官方文档案例的样子，有助于理解。

其实，Rust 的 futures 库并不完整，更多是在定义一个 trait，虽然给了一些实现宏，但还是留有大量的空间给我们去实现，好在第三方库tokio 给出了很好的实现，但正如官方文档所说，你的确可以直接去学习那些库的用法，但最后总是要回过头来了解，futures 库做了什么，或者说定义了什么，Rust 期待的异步模型是什么样子的，这些底层原理还是要搞懂的。

不像官方文档直接拿出futures trait做例子，这一节，暂时不细讲 futures trait 都定义了什么，我们先把最基础的异步模型讲清楚，再引入 futures trait ，以及其它更多概念，这样，我们先引入一个基本模型，然后再逐个引入各种概念（比如futures trait）从而理解引入的概念解决了什么问题，或者用于做什么的，这样比官方文档直接把大量概念加入进来更容易理解。

为了更简单更容易理解，我的例子甚至不使用网络库，文件库这些 IO 库，只留下最精简的模型代码，这样我们可以完全聚焦在异步编程模型上，后面我们再加入 IO 库，从而理解 IO 任务和 CPU 任务分离模型基础。

当我们把这些事情都完全展现出来后，再去看 tokio 库，就有了然于胸的感觉了。



## 生产者和消费者模型

异步编程最经典的模型就是生产者和消费者模型，它的原理非常简单：即生产者生产消息，消息放入队列，队列的消息先进先出，因此消费者在队列另一头读出消息然后处理。把这个模型套到上面提到的 IO 任务和 CPU 任务上，那就是，生产者是 IO 任务，而 消费者是 CPU 任务，中间用队列通信，当 CPU 任务遇到 IO 时因为要被阻塞了，因此，会把任务放回队列中，待下次调度，自己会去做其它的CPU任务，用一张简单的图画出来就是这个样子：



